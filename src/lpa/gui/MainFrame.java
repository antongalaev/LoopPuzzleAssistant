/*
 * @author Galaev Anton
 * Date: 19.11.2012
 */
package lpa.gui;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.Point;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Scanner;
import java.util.Stack;
import java.util.concurrent.CancellationException;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.SwingWorker;
import javax.swing.filechooser.FileFilter;
import javax.swing.filechooser.FileNameExtensionFilter;
import lpa.model.*;
import lpa.solvers.Backtracker;
import lpa.solvers.Checker;
import lpa.solvers.Strategies;
import lpa.solvers.command.ChangeStateCommand;
import lpa.solvers.command.Command;
import lpa.solvers.command.CompoundCommand;

/**
 * Class of main frame of the program.
 */
public class MainFrame extends javax.swing.JFrame {
    
    /**
     * Public constructor for MainFrame.
     * Creates new MainFrame.
     */
    public MainFrame() {
        initComponents();
        // initialize undo-redo facility
        undoStack = new Stack<>();
        redoStack = new Stack<>();
        // initialize violation indexes
        iV = jV = -1;
        // only text files are allowed to open and save
        FileFilter filter = new FileNameExtensionFilter("Text file", "txt");
        jFileChooser.setAcceptAllFileFilterUsed(false);
        jFileChooser.setFileFilter(filter);
}


    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jFileChooser = new javax.swing.JFileChooser();
        jSplitPane1 = new javax.swing.JSplitPane();
        jPuzzlePanel = new javax.swing.JPanel(){
            private LoopPuzzle puzzle;
            public void setPuzzle(LoopPuzzle lp) {
                puzzle = lp;
            }
            @Override
            public void paintComponent(Graphics g) {
                super.paintComponent(g);
                paintPuzzlePanel(this, g);
            }
        }
        ;
        jScrollPane1 = new javax.swing.JScrollPane();
        jTextArea1 = new javax.swing.JTextArea();
        jMenuBar1 = new javax.swing.JMenuBar();
        jMenuFile = new javax.swing.JMenu();
        jMenuItemOpen = new javax.swing.JMenuItem();
        jMenuItemCreate = new javax.swing.JMenuItem();
        jMenuItemSave = new javax.swing.JMenuItem();
        jMenuItemQuit = new javax.swing.JMenuItem();
        jMenuEdit = new javax.swing.JMenu();
        jMenuItemUndo = new javax.swing.JMenuItem();
        jMenuItemRedo = new javax.swing.JMenuItem();
        jCheckBoxMenuItemEditMode = new javax.swing.JCheckBoxMenuItem();
        jMenuPuzzle = new javax.swing.JMenu();
        jMenuItemClear = new javax.swing.JMenuItem();
        jMenuItemVerify = new javax.swing.JMenuItem();
        jMenuItemApplyStrategies = new javax.swing.JMenuItem();
        jMenuItemSolveAll = new javax.swing.JMenuItem();
        jMenuItemSolveOne = new javax.swing.JMenuItem();
        jMenuItemAbort = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Loop Puzzle Assistant");
        setCursor(new java.awt.Cursor(java.awt.Cursor.DEFAULT_CURSOR));
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentResized(java.awt.event.ComponentEvent evt) {
                frameResized(evt);
            }
        });

        jSplitPane1.setDividerLocation(300);
        jSplitPane1.setResizeWeight(1.0);

        jPuzzlePanel.setBackground(new java.awt.Color(255, 255, 255));
        jPuzzlePanel.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jPuzzlePanelMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout jPuzzlePanelLayout = new javax.swing.GroupLayout(jPuzzlePanel);
        jPuzzlePanel.setLayout(jPuzzlePanelLayout);
        jPuzzlePanelLayout.setHorizontalGroup(
            jPuzzlePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 299, Short.MAX_VALUE)
        );
        jPuzzlePanelLayout.setVerticalGroup(
            jPuzzlePanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 345, Short.MAX_VALUE)
        );

        jSplitPane1.setLeftComponent(jPuzzlePanel);

        jTextArea1.setEditable(false);
        jTextArea1.setColumns(20);
        jTextArea1.setFont(new java.awt.Font("Monospaced", 0, 14)); // NOI18N
        jTextArea1.setRows(5);
        jScrollPane1.setViewportView(jTextArea1);

        jSplitPane1.setRightComponent(jScrollPane1);

        jMenuFile.setText("File");

        jMenuItemOpen.setText("Open");
        jMenuItemOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemOpenActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemOpen);

        jMenuItemCreate.setText("Create");
        jMenuItemCreate.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemCreateActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemCreate);

        jMenuItemSave.setText("Save");
        jMenuItemSave.setEnabled(false);
        jMenuItemSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSaveActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemSave);

        jMenuItemQuit.setText("Exit");
        jMenuItemQuit.setToolTipText("");
        jMenuItemQuit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemQuitActionPerformed(evt);
            }
        });
        jMenuFile.add(jMenuItemQuit);

        jMenuBar1.add(jMenuFile);

        jMenuEdit.setText("Edit");

        jMenuItemUndo.setText("Undo");
        jMenuItemUndo.setEnabled(false);
        jMenuItemUndo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemUndoActionPerformed(evt);
            }
        });
        jMenuEdit.add(jMenuItemUndo);

        jMenuItemRedo.setText("Redo");
        jMenuItemRedo.setEnabled(false);
        jMenuItemRedo.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemRedoActionPerformed(evt);
            }
        });
        jMenuEdit.add(jMenuItemRedo);

        jCheckBoxMenuItemEditMode.setText("Edit Mode");
        jCheckBoxMenuItemEditMode.setEnabled(false);
        jCheckBoxMenuItemEditMode.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCheckBoxMenuItemEditModeActionPerformed(evt);
            }
        });
        jMenuEdit.add(jCheckBoxMenuItemEditMode);

        jMenuBar1.add(jMenuEdit);

        jMenuPuzzle.setText("Puzzle");

        jMenuItemClear.setText("Clear");
        jMenuItemClear.setEnabled(false);
        jMenuItemClear.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemClearActionPerformed(evt);
            }
        });
        jMenuPuzzle.add(jMenuItemClear);

        jMenuItemVerify.setText("Verify");
        jMenuItemVerify.setEnabled(false);
        jMenuItemVerify.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemVerifyActionPerformed(evt);
            }
        });
        jMenuPuzzle.add(jMenuItemVerify);

        jMenuItemApplyStrategies.setText("Apply Strategies");
        jMenuItemApplyStrategies.setEnabled(false);
        jMenuItemApplyStrategies.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemApplyStrategiesActionPerformed(evt);
            }
        });
        jMenuPuzzle.add(jMenuItemApplyStrategies);

        jMenuItemSolveAll.setText("Solve All");
        jMenuItemSolveAll.setEnabled(false);
        jMenuItemSolveAll.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSolveAllActionPerformed(evt);
            }
        });
        jMenuPuzzle.add(jMenuItemSolveAll);

        jMenuItemSolveOne.setText("Solve One");
        jMenuItemSolveOne.setEnabled(false);
        jMenuItemSolveOne.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemSolveOneActionPerformed(evt);
            }
        });
        jMenuPuzzle.add(jMenuItemSolveOne);

        jMenuItemAbort.setText("Abort");
        jMenuItemAbort.setEnabled(false);
        jMenuItemAbort.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMenuItemAbortActionPerformed(evt);
            }
        });
        jMenuPuzzle.add(jMenuItemAbort);

        jMenuBar1.add(jMenuPuzzle);

        setJMenuBar(jMenuBar1);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jSplitPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 557, Short.MAX_VALUE)
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jSplitPane1)
                .addContainerGap())
        );

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-593)/2, (screenSize.height-428)/2, 593, 428);
    }// </editor-fold>//GEN-END:initComponents
     
    /**
     * Paints a puzzle on a given puzzle.
     * 
     * @param p panel for painting a puzzle
     * @param g graphics for painting
     */
    private void paintPuzzlePanel(javax.swing.JPanel p, Graphics g) {
        if (lp == null) {
            return;
        }
        int currX, currY;
        rectWidth = Math.min(jPuzzlePanel.getWidth(), jPuzzlePanel.getHeight())
                / Math.max(lp.getWidth(),lp.getHeight()) * 3 / 2;
        int fontSize = rectWidth / 2;
        g.setFont(new Font("SansSerif", 0, fontSize));
        currY = INDENT;

        for (int i = 0; i < lp.getHeight(); ++ i) { // go through rows
            currX = INDENT;
            for (int j = 0; j < lp.getWidth(); ++ j) { // go through columns
                g.setColor(Color.BLACK);
                GridElement currElement = lp.getGrid().getElement(i, j);
                if (currElement instanceof Vertex) { 
                    // drawing vertices only if yes-edges around
                    if (((Vertex) currElement).countYesEdges() > 1) { 
                        g.setColor(Color.BLACK);
                        if (puzzleIsSolved) { // if solved
                            g.setColor(Color.GREEN); // highlight green
                        }
                        g.fillOval(currX + 1, currY + 1, 8, 8);
                    }
                    currX += 10;
                }
                if (currElement instanceof Edge) { // drawing edges
                    if (i % 2 == 0) { // horizontal edge           
                        if (((Edge) currElement).getState() 
                                == EdgeState.PRESENT) {
                            g.setColor(Color.BLACK);
                            if (puzzleIsSolved) { // if solved
                                g.setColor(Color.GREEN); // highlight green
                            }
                            g.fillRoundRect(currX, currY, rectWidth, 
                                    RECT_HEIGHT, 5, 5);
                        } else if (((Edge) currElement).getState() 
                                == EdgeState.UNDETERMINED) {
                            g.setColor(Color.GRAY);
                            g.fillRoundRect(currX, currY, rectWidth, 
                                    RECT_HEIGHT, 5, 5);
                        } else {
                            g.drawRoundRect(currX, currY, rectWidth, 
                                    RECT_HEIGHT, 5, 5);
                        }
                        currX += rectWidth;
                    } else {                        
                        if (((Edge) currElement).getState() ==
                                EdgeState.PRESENT) {
                            g.setColor(Color.BLACK);
                            if (puzzleIsSolved) { // if solved
                                g.setColor(Color.GREEN); // highlight green
                            }
                            g.fillRoundRect(currX, currY, RECT_HEIGHT,
                                    rectWidth, 5, 5);
                        } else if (((Edge) currElement).getState() ==
                                EdgeState.UNDETERMINED) {
                            g.setColor(Color.GRAY);
                            g.fillRoundRect(currX, currY, RECT_HEIGHT, 
                                    rectWidth, 5, 5);
                        } else {
                            g.drawRoundRect(currX, currY, RECT_HEIGHT, 
                                    rectWidth, 5, 5);
                        }
                        currX += RECT_HEIGHT;
                    }
                }
                if (currElement instanceof Cell) {
                    g.drawString(((Cell) currElement).toString(),
                            currX + rectWidth / 3, currY + rectWidth / 2);
                    currX += rectWidth;
                }
            }
            if (i % 2 == 0) {
                currY += RECT_HEIGHT;
            } else {
                currY += rectWidth;
            }
        }
        drawRuleViolations(iV, jV, g);
    }

    private void jMenuItemOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemOpenActionPerformed
        int retVal = jFileChooser.showOpenDialog(this); // show dialog
        if (retVal == JFileChooser.APPROVE_OPTION) { // file was chosen
            File file = jFileChooser.getSelectedFile();
            try {
                Scanner inp = new Scanner(file); // create scanner
                lp = new LoopPuzzle("Loop Puzzle", inp); // create puzzle
                jTextArea1.append("Puzzle loaded.\n"); // print info
                // update all the settings and GUI:
                initFrame();
            } catch (FileNotFoundException e) {
                jTextArea1.append("problem accessing file "
                        + file.getAbsolutePath() + "\n");
                jTextArea1.append(e.getMessage() + "\n");
            } catch (NullPointerException e) {
                jTextArea1.append(e.getMessage() + "\n");
            } catch (IllegalArgumentException e) {
                jTextArea1.append(e.getMessage() + "\n");
            } catch (Exception e) {
                jTextArea1.append("Unexpected error.\n");
                jTextArea1.append(e.getMessage() + "\n");
            }
        } else { // file was not chosen
            jTextArea1.append("File access cancelled by user.\n");
        }
    }//GEN-LAST:event_jMenuItemOpenActionPerformed

    private void jMenuItemQuitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemQuitActionPerformed
        System.exit(0); // exit
    }//GEN-LAST:event_jMenuItemQuitActionPerformed

    private void jPuzzlePanelMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jPuzzlePanelMouseClicked
        if (lp == null) { // if puzzle is not loaded yet, exit
            return;
        }
        Point p = evt.getPoint();
        int ii = -1, jj = -1; // init indexes of clicked grid element
        for (int i = 0; i < lp.getHeight(); ++ i) { // search for Y match
            if (getCoordinate(i) < p.y &&
                    p.y < getCoordinate(i + 1)) { // match for Y coordinate
                for (int j = 0; j < lp.getWidth(); ++ j) { // search for X match
                    if (getCoordinate(j) < p.x &&
                            p.x < getCoordinate(j + 1)) { // match for X
                        ii = i;
                        jj = j;
                        break;
                    }
                } 
                break;
            }
        } // end of search
        if (ii == -1 || jj == -1) { // if no matches were found, exit
            return;
        }
        GridElement ge;
        ge = lp.getGrid().getElement(ii, jj); // get clicked element
        
        if (ge instanceof Edge) { // if clicked element is an edge
            Edge edge = (Edge) ge;
            EdgeState currState = edge.getState();
            if (currState == EdgeState.UNDETERMINED) { // if it's a maybe-edge
                Command command;
                command = new ChangeStateCommand(edge, EdgeState.PRESENT);
                command.execute(); // change to yes-edge
                undoStack.push(command);
            }
            if (currState == EdgeState.PRESENT) { // if it's a yes-edge
                Command command;
                command = new ChangeStateCommand(edge, EdgeState.ABSENT);
                command.execute(); // change to no-edge
                undoStack.push(command);
            }
            if (currState == EdgeState.ABSENT) { // if it's a no-edge
                Command command;
                command = new ChangeStateCommand(edge, EdgeState.UNDETERMINED);
                command.execute(); // change to maybe-edge
                undoStack.push(command);
            }     
            redoStack.clear();
            puzzleIsSolved = false; // because puzzle has been chanded
        }
        // if clicked element is a cell and edit mode is ON
        if (editMode && ge instanceof Cell) { 
            Cell cell = (Cell) ge;
            int digit = cell.getDigit();
            if (digit == 3) { // change to an empty cell
                cell.setDigit(-1);
            } else { // increment digit
                cell.setDigit(++ digit);
            }
            puzzleIsSolved = false; // because puzzle has been chanded
        }
        updateFrame(); // update GUI
    }//GEN-LAST:event_jPuzzlePanelMouseClicked

    private void jMenuItemUndoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemUndoActionPerformed
        Command command = undoStack.pop();
        command.undo();
        redoStack.push(command);
        updateFrame();
    }//GEN-LAST:event_jMenuItemUndoActionPerformed

    private void jMenuItemRedoActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemRedoActionPerformed
        Command command = redoStack.pop();
        command.execute();
        undoStack.push(command);
        updateFrame();
    }//GEN-LAST:event_jMenuItemRedoActionPerformed

    private void jMenuItemApplyStrategiesActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemApplyStrategiesActionPerformed
        strategies.setPuzzle(lp);
        Command command = strategies.applyStrategies();
        undoStack.push(command);
        redoStack.clear();
        updateFrame();
    }//GEN-LAST:event_jMenuItemApplyStrategiesActionPerformed

    private void jMenuItemVerifyActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemVerifyActionPerformed
        Checker checker = new Checker(lp.getGrid()); // create checker
        String response, message; // information

        if (checker.checkGrid()) { // if no violations found
            if (checker.additionalStrictCheck()) { // if puzzle is solved
                response = "Congratulations! The puzzle is solved!";
                puzzleIsSolved = true;
                JOptionPane.showMessageDialog(this, response);
            } else { // puzzle is not solved
                response = "No violations have been found.\n"
                        + "However, the puzzle is not solved yet:";
            }
        } else { // violations have been found
            response = "Rule violations have been found:";
        }
        iV = checker.getRowViolationIndex();
        jV = checker.getColViolationIndex();
        message = checker.getMessage();
        repaint();
        jTextArea1.append("\n" + response + "\n" + message + "\n");
    }//GEN-LAST:event_jMenuItemVerifyActionPerformed

    private void jMenuItemSolveAllActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSolveAllActionPerformed
        solvePuzzle(false);
    }//GEN-LAST:event_jMenuItemSolveAllActionPerformed

    private void jMenuItemClearActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemClearActionPerformed
        Command command = clearPuzzle();
        undoStack.push(command);
        redoStack.clear();
        updateFrame();
    }//GEN-LAST:event_jMenuItemClearActionPerformed

    private void jMenuItemSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSaveActionPerformed
        int option = jFileChooser.showSaveDialog(this);
        if (option == JFileChooser.APPROVE_OPTION) {
            File file = jFileChooser.getSelectedFile();
            if (file != null) {
                try (FileWriter fw = new FileWriter(file.getAbsolutePath())) {
                    fw.write(lp.getGrid().toString());
                    fw.close();
                } catch (IOException e) {
                    System.out.println(e.getMessage());
                }
            }
        }
    }//GEN-LAST:event_jMenuItemSaveActionPerformed

    private void jMenuItemAbortActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemAbortActionPerformed
        if (puzzleWorker != null) {
            jTextArea1.append("\nSolving aborted by user.\n");
            backtracker.abort();
        }
    }//GEN-LAST:event_jMenuItemAbortActionPerformed

    private void jMenuItemSolveOneActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemSolveOneActionPerformed
       solvePuzzle(true);
    }//GEN-LAST:event_jMenuItemSolveOneActionPerformed

    private void jCheckBoxMenuItemEditModeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCheckBoxMenuItemEditModeActionPerformed
        if (jCheckBoxMenuItemEditMode.isSelected()) { // if edit mode is ON
            editMode = true;
            jMenuItemApplyStrategies.setEnabled(false);
            jMenuItemSolveAll.setEnabled(false);
            jMenuItemSolveOne.setEnabled(false);
            jMenuItemVerify.setEnabled(false);
        } else { //if edit mode is OFF
            editMode = false;
            jMenuItemApplyStrategies.setEnabled(true);
            jMenuItemSolveAll.setEnabled(true);
            jMenuItemSolveOne.setEnabled(true);
            jMenuItemVerify.setEnabled(true);
        }
    }//GEN-LAST:event_jCheckBoxMenuItemEditModeActionPerformed

    private void frameResized(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_frameResized
        jSplitPane1.setDividerLocation(0.6); // update divider location
    }//GEN-LAST:event_frameResized

    private void jMenuItemCreateActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMenuItemCreateActionPerformed
        int width, height;
        String sWidth = (String) JOptionPane.showInputDialog(this, "Set width",
                "New puzzle", JOptionPane.PLAIN_MESSAGE, null, null, "");
        String sHeight = (String) JOptionPane.showInputDialog(this, "Set height",
                "New puzzle", JOptionPane.PLAIN_MESSAGE, null, null, "");

        try {
            width = 2 * Integer.parseInt(sWidth) + 1;
            height = 2 * Integer.parseInt(sHeight) + 1;
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(this,
                    "Incorrect values. Try again please.");
            return;
        }
        if (! (width > 3 && height > 3)) {
            JOptionPane.showMessageDialog(this,
                    "Incorrect values. Try again please.");
            return;
        }
        try {
            Grid empty = Grid.createEmpty(height, width); // create empty grid
            lp = new LoopPuzzle("Created", new Scanner(empty.toString()));
            jTextArea1.append("Puzzle created.\n"); // print info
            // update all the settings and GUI:
            initFrame();
        } catch (IllegalArgumentException e) {
            JOptionPane.showMessageDialog(this,
                    e.getMessage() + "\nTry again please.");
        }
    }//GEN-LAST:event_jMenuItemCreateActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(MainFrame.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            @Override
            public void run() {
                new MainFrame().setVisible(true);
            }
        });
    }
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JCheckBoxMenuItem jCheckBoxMenuItemEditMode;
    private javax.swing.JFileChooser jFileChooser;
    private javax.swing.JMenuBar jMenuBar1;
    private javax.swing.JMenu jMenuEdit;
    private javax.swing.JMenu jMenuFile;
    private javax.swing.JMenuItem jMenuItemAbort;
    private javax.swing.JMenuItem jMenuItemApplyStrategies;
    private javax.swing.JMenuItem jMenuItemClear;
    private javax.swing.JMenuItem jMenuItemCreate;
    private javax.swing.JMenuItem jMenuItemOpen;
    private javax.swing.JMenuItem jMenuItemQuit;
    private javax.swing.JMenuItem jMenuItemRedo;
    private javax.swing.JMenuItem jMenuItemSave;
    private javax.swing.JMenuItem jMenuItemSolveAll;
    private javax.swing.JMenuItem jMenuItemSolveOne;
    private javax.swing.JMenuItem jMenuItemUndo;
    private javax.swing.JMenuItem jMenuItemVerify;
    private javax.swing.JMenu jMenuPuzzle;
    private javax.swing.JPanel jPuzzlePanel;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JSplitPane jSplitPane1;
    private javax.swing.JTextArea jTextArea1;
    // End of variables declaration//GEN-END:variables
    
    /** The Loop Puzzle (model). */
    private LoopPuzzle lp;
    
    /** The undo stack. */
    private Stack<Command> undoStack;
   
    /** The redo stack. */
    private Stack<Command> redoStack;
    
    /** The width of a puzzle cell. */
    private int rectWidth;
    
    /** The height of a horizontal puzzle edge. */
    private static final int RECT_HEIGHT = 10;
    
    /** Indent on panel. */
    private static final int INDENT = 10;
    
    /** Row and column indexes of rule violating grid elements. */
    private int iV, jV;
    
    /** Edit mode switcher (toggle). */
    private boolean editMode;
    
    /** 
     * Boolean variable, that shows whether puzzle is solved.
     * Used for highlighting edges in green, when puzzle is solved.
     */
    private boolean puzzleIsSolved;
    
    /** Backtracker variable for solving the loop puzzle */
    private Backtracker backtracker = new Backtracker();
    
    /** Strategies variable for applying strategies to puzzle */
    private Strategies strategies = new Strategies();
    
    /** The handle for the separate thread. */
    private PuzzleWorker puzzleWorker;   

    /**
     * A method, that gets row OR column index of a grid element and returns y
     * OR x left top pixel coordinate of that grid element on PuzzlePanel.
     *
     * @param i row OR column index of a grid element
     * @return y OR x coordinate of grid element left top pixel on PuzzlePanel
     * @pre {@code  i >= 0 && (i <= lp.getWidth() || i <= lp.getHeight())}
     * @post {@code \result == left top pixel coordinate of 
     *       grid elementin the i-th row OR column}
     */
    private int getCoordinate(int i) {
        return INDENT + i / 2 * rectWidth + (i / 2 + i % 2) * RECT_HEIGHT;
    }

    /**
     * An auxiliary method for highlighting
     * the violating puzzle element(s) in red.
     * If iV or jV equals -1 then there are no violating
     * puzzle elements to highlight.
     * 
     * @param iV row violating index
     * @param jV column violating index
     * @param g Graphics for drawing
     */
    private void drawRuleViolations(int iV, int jV, Graphics g) {
        if (iV == -1 || jV == -1) { // no violating elements
            return;
        }
        GridElement ge = lp.getGrid().getElement(iV, jV); //get violation
        int fontSize = rectWidth / 2;
        g.setFont(new Font("SansSerif", 0, fontSize));
        g.setColor(Color.RED);
        int currY, currX;

        if (ge instanceof Cell) { // if violation is around a cell
            Cell cell = (Cell) ge;
            if (cell.countYesEdges() == 0) { // if there are no edges around
                currY = getCoordinate(iV);   // highlight the digit
                currX = getCoordinate(jV);
                g.drawString(cell.toString(),
                        currX + rectWidth / 3, currY + rectWidth / 2);
            } else { // if there are incorrect number of edges around
                for (Edge edge : cell.getEdges()) { // for all edges around
                    if (edge.getState() == EdgeState.PRESENT) {
                        currY = getCoordinate(edge.getY());
                        currX = getCoordinate(edge.getX());
                        if (edge.getX() % 2 == 1) { // horizontal edge
                            g.fillRect(currX, currY, rectWidth, RECT_HEIGHT);
                        } else { // vertical edge
                            g.fillRect(currX, currY, RECT_HEIGHT, rectWidth);
                        }
                    }
                } // all present edges were highlighted 
            }
        }
        if (ge instanceof Vertex) { // if violation is around a vertex
            Vertex vertex = (Vertex) ge;
            currY = getCoordinate(iV);
            currX = getCoordinate(jV);
            g.fillOval(currX, currY, 10, 10); // highlight the vertex
            for (Edge edge : vertex.getEdges()) { // and all present edges
                if (edge.getState() == EdgeState.PRESENT) {
                    currY = getCoordinate(edge.getY());
                    currX = getCoordinate(edge.getX());
                    if (edge.getX() % 2 == 1) {
                        g.fillRect(currX, currY, rectWidth, RECT_HEIGHT);
                    } else {
                        g.fillRect(currX, currY, RECT_HEIGHT, rectWidth);
                    }
                }
            } // all present edges were highlighted 
        }
    }

    /**
     * An auxiliary method, that sets all edges to UNDETERMINED state.
     *
     * @return a compound command of all changes made in puzzle
     */
    private Command clearPuzzle() {
        CompoundCommand command = new CompoundCommand();

        for (GridElement ge : lp.getGrid()) { // go through elements
            if (ge instanceof Edge) {
                Command c;
                c = new ChangeStateCommand((Edge) ge, EdgeState.UNDETERMINED);
                c.execute();
                command.add(c);
            }
        }
        return command;
    }

    /**
     * An auxiliary method, that is used to solve the loop puzzle.
     * It is called, when user clicks "Solve All" or "Solve One" 
     * menu items.
     * <p>
     * If "Solve One" clicked, then parameter is true, and backtracking
     * continues only until first solution is found. 
     * Then it is shown to user via GUI.
     * <p>
     * If "Solve All" clicked, then parameter is false, and backtracking
     * goes to the end until it finds all the solutions. 
     * Solutions are shown to user via text area.
     * 
     * @param solveOne find one or all solutions
     */
    private void solvePuzzle(boolean solveOne) {
        // do not allow multiple invocations
        jMenuItemSolveAll.setEnabled(false);
        jMenuItemSolveOne.setEnabled(false);
        // copy puzzle (no conflicts allowed)
        LoopPuzzle puzzleCopy = new LoopPuzzle("puzzle",
                new Scanner(lp.getGrid().toString()));
        backtracker.setPuzzle(puzzleCopy);
        //report the beginning
        jTextArea1.append("\nSolving began.\n");
        puzzleWorker = new PuzzleWorker();
        puzzleWorker.setSolveOne(solveOne); // set parameter
        // pass the reportProgress event on to the puzzleWorker
        backtracker.setListener(puzzleWorker);
        // pass the PropertyChangeEvent to the text area
        puzzleWorker.addPropertyChangeListener(
                new PropertyChangeListener() {
                    @Override
                    public void propertyChange(PropertyChangeEvent evt) {
                        if (evt.getPropertyName().equals("progress")) {
                            int progress = (Integer) evt.getNewValue();
                            jTextArea1.append("Work in progress: " 
                                    + progress + "%\n");
                        }
                    }
                });
        puzzleWorker.execute(); // start the backtracking
        jMenuItemAbort.setEnabled(true); // allow abort               
    }
    
    /**
     * A method, that updates GUI and undo-redo facility.
     * <p>
     * What is updating:
     * <ul>
     * <il>Firstly, updates edge groups for grid cells and grid vertices.
     * <il>Secondly, updates undo-redo menu items availability.
     * <il>Finally, repaints GUI.
     * </ul>
     * Method is called every time, when some significant changes are made.
     */
    private void updateFrame() {
        lp.getGrid().setElementGroups();
        jMenuItemUndo.setEnabled(! undoStack.empty());
        jMenuItemRedo.setEnabled(! redoStack.empty());
        repaint();
    }

    /**
     * Sets initial state of frame.
     * Called only when opening or creating new puzzle.
     */
    private void initFrame() {
        backtracker.setPuzzle(lp);
        strategies.setPuzzle(lp);
        jMenuItemSave.setEnabled(true);
        jMenuItemApplyStrategies.setEnabled(true);
        jMenuItemClear.setEnabled(true);
        jMenuItemSolveAll.setEnabled(true);
        jMenuItemSolveOne.setEnabled(true);
        jMenuItemVerify.setEnabled(true);
        jCheckBoxMenuItemEditMode.setEnabled(true);
        undoStack.clear();
        redoStack.clear();
        updateFrame();
    }
    /**
     * Inner class to control separate thread for solving Loop puzzle through
     * backtracking.
     */
    private class PuzzleWorker extends SwingWorker<Void, Void>
            implements Backtracker.ReportListener {
        
        /** Number of solutions found */
        private int solutionCounter;
        
        /**
         * String representation of the first solution
         * found with backtracker 
         */
        private String firstSolution;
        
        /** Flag, that is true, when only one solution is desired */
        private boolean solveOne;
        
        /**
         * Setter for {@code solveOne}
         * 
         * @param solveOne the solveOne to set
         */
        public void setSolveOne(boolean solveOne) {
            this.solveOne = solveOne;
        }
        
        /**
         * Here backtracking is done in a background thread.
         * This method is called in the background thread,
         * via {@code PuzzleWorker.execute()}.
         */
        @Override
        protected Void doInBackground() throws Exception {
            solutionCounter = 0;
            backtracker.solve();
            return null;
        }

        /**
         * After the puzzle is solved it can be shown in the GUI. 
         * This method is called in the GUI thread.
         */
        @Override
        protected void done() {
            jMenuItemAbort.setEnabled(false); // disable further aborts
            try {
                if (solutionCounter == 0) {
                    jTextArea1.append("No solutions have been found.\n");
                    updateFrame();
                } else {
                    if (solveOne) {
                        // show the first solution via GUI
                        Scanner inp = new Scanner(firstSolution);
                        lp = new LoopPuzzle("Loop Puzzle", inp);
                        // update
                        updateFrame();
                    }
                    jTextArea1.append("Puzzle is solved.\n");
                    puzzleIsSolved = true;
                    iV = -1;
                    jV = -1;
                    updateFrame();
                }
            } catch (CancellationException ex) {
                jTextArea1.append("Canceled by user.\n");
                repaint();
            } catch (Exception ex) {
                jTextArea1.append("Unknown error.\n");
                System.out.println(ex); //show details in stdout
                repaint();
            }
            // allow new calculations
            jMenuItemSolveAll.setEnabled(true);
            jMenuItemSolveOne.setEnabled(true);
        }

        /**
         * Reports progress to the text area.
         * 
         * @param progress 
         */
        @Override
        public void reportProgress(int progress) {
            setProgress(progress);
        }

        /**
         * Reports solutions to the text area or save it for GUI.
         * <p>
         * If {@code solveOne == true} method is called just once, 
         * it saves found solution, which is then will be shown via GUI.
         * <p>
         * Otherwise, reports all found solutions to the text area.
         * 
         * @param progress 
         */
        @Override
        public void reportSolution(String solution) {
            ++ solutionCounter;
            // if only one solution is desired
            if (solveOne && solutionCounter == 1) {
                firstSolution = solution;
                backtracker.abort();
            } else { // if all solutions are desired
                jTextArea1.append("Solution #" + solutionCounter + " found:\n");
                jTextArea1.append(solution + "\n");
            }                  
        }        
    }
}